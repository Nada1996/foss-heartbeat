{"url": "https://api.github.com/repos/rails-girls-summer-of-code/rgsoc-teams/pulls/comments/131541289", "pull_request_review_id": 54533021, "id": 131541289, "diff_hunk": "@@ -1,5 +1,21 @@\n class ConferencePreference < ActiveRecord::Base\n+  validates :terms_accepted?, acceptance: true", "path": "app/models/conference_preference.rb", "position": null, "original_position": 2, "commit_id": "abaff13621ec0f202bebf0f042b24b63b8216afb", "original_commit_id": "84a69d070576db890c4327d0369a4bf91df2be29", "user": {"login": "klappradla", "id": 3491815, "avatar_url": "https://avatars3.githubusercontent.com/u/3491815?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klappradla", "html_url": "https://github.com/klappradla", "followers_url": "https://api.github.com/users/klappradla/followers", "following_url": "https://api.github.com/users/klappradla/following{/other_user}", "gists_url": "https://api.github.com/users/klappradla/gists{/gist_id}", "starred_url": "https://api.github.com/users/klappradla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klappradla/subscriptions", "organizations_url": "https://api.github.com/users/klappradla/orgs", "repos_url": "https://api.github.com/users/klappradla/repos", "events_url": "https://api.github.com/users/klappradla/events{/privacy}", "received_events_url": "https://api.github.com/users/klappradla/received_events", "type": "User", "site_admin": false}, "body": "Almost \ud83d\udcaa \r\n\r\nYou can spare the two `attr_accessor`s - it's just about the input that's coming in via the controller (essentially the form in the end). So you need two validations:\r\n```ruby\r\nvalidates : terms_of_ticket?, acceptance: true\r\nvalidates : terms_of_travel?, acceptance: true\r\n```\r\n\r\nPlus: remove the `terms_accepted?` method, Rails does all this alone, including putting together the respective error message. The practical part about this: the validation only works if the attribute is give - so you'll still be able to create and update `ConferencePreferences` outside the context of user-interaction.\r\n\r\nI put together a small [Rails app for you as an example](https://gist.github.com/klappradla/80eeda7538fd5a924ef83817156b8ffe):\r\n```ruby\r\nbegin\r\n  require \"bundler/inline\"\r\nrescue LoadError => e\r\n  $stderr.puts \"Bundler version 1.10 or later is required. Please update your Bundler\"\r\n  raise e\r\nend\r\n\r\ngemfile(true) do\r\n  source \"https://rubygems.org\"\r\n\r\n  gem \"rails\"\r\n  gem \"pg\"\r\n  gem \"pry\"\r\nend\r\n\r\nrequire \"active_record\"\r\n\r\nActiveRecord::Base.establish_connection(adapter: \"postgresql\", database: \"validation_example\")\r\n\r\nActiveRecord::Schema.define do\r\n  create_table :users, force: true do |t|\r\n    t.string :name\r\n    t.timestamps\r\n  end\r\nend\r\n\r\nclass User < ActiveRecord::Base\r\n  validates_acceptance_of :terms_of_service\r\nend\r\n\r\nbinding.pry\r\n```\r\n\r\nIt's a Rails app in one file. In order to run it, you have to do:\r\n```sh\r\ncreatedb validation_example\r\n```\r\nonce, and then\r\n```sh\r\nruby validation_example.rb # or however the file is called\r\n```\r\nTo run the app and get into an interactive pry session\r\n\r\n**But you don't have to do any of this**, I ran the app for you and illustrated some examples of how this type of validation works:\r\n```ruby\r\n[1] pry(main)> User.new.valid?\r\n=> true\r\n[2] pry(main)> user = User.new(terms_of_service: \"1\")\r\n=> #<User:0x007f951902e9e0 id: nil, name: nil, created_at: nil, updated_at: nil>\r\n[3] pry(main)> user.valid?\r\n=> true\r\n[4] pry(main)> user = User.new(terms_of_service: \"0\")\r\n=> #<User:0x007f951813ed90 id: nil, name: nil, created_at: nil, updated_at: nil>\r\n[5] pry(main)> user.valid?\r\n=> false\r\n[6] pry(main)> user.errors\r\n=> #<ActiveModel::Errors:0x007f9518d0d298\r\n @base=#<User:0x007f951813ed90 id: nil, name: nil, created_at: nil, updated_at: nil>,\r\n @details={:terms_of_service=>[{:error=>:accepted}]},\r\n @messages={:terms_of_service=>[\"must be accepted\"]}>\r\n[7] pry(main)> user = User.new(terms_of_service: \"2\")\r\n=> #<User:0x007f9518458df0 id: nil, name: nil, created_at: nil, updated_at: nil>\r\n[8] pry(main)> user.valid?\r\n=> false\r\n[9] pry(main)> user.errors\r\n=> #<ActiveModel::Errors:0x007f951826e8c8\r\n @base=#<User:0x007f9518458df0 id: nil, name: nil, created_at: nil, updated_at: nil>,\r\n @details={:terms_of_service=>[{:error=>:accepted}]},\r\n @messages={:terms_of_service=>[\"must be accepted\"]}>\r\n[10] pry(main)>\r\n```\r\n\r\nSo as you see, Rails does all the work already for you! I would prefer to have Rails do the work in this case, instead of having to implement it ourself and testing it (we don't have to test Rails' internals, we'll just assume they work \ud83d\ude09 )\r\n\r\nSo the boolean fields just have to be present in the form and allowed in the controller. For the rest, Rails will take care of things.\r\n\r\nEverything clear? Just ask me if this is still confusing", "created_at": "2017-08-06T12:02:30Z", "updated_at": "2017-08-08T00:45:00Z", "html_url": "https://github.com/rails-girls-summer-of-code/rgsoc-teams/pull/810#discussion_r131541289", "pull_request_url": "https://api.github.com/repos/rails-girls-summer-of-code/rgsoc-teams/pulls/810", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/rails-girls-summer-of-code/rgsoc-teams/pulls/comments/131541289"}, "html": {"href": "https://github.com/rails-girls-summer-of-code/rgsoc-teams/pull/810#discussion_r131541289"}, "pull_request": {"href": "https://api.github.com/repos/rails-girls-summer-of-code/rgsoc-teams/pulls/810"}}, "body_html": "<p>Almost <g-emoji class=\"g-emoji\" alias=\"muscle\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f4aa.png\">\ud83d\udcaa</g-emoji></p>\n<p>You can spare the two <code>attr_accessor</code>s - it's just about the input that's coming in via the controller (essentially the form in the end). So you need two validations:</p>\n<div class=\"highlight highlight-source-ruby\"><pre>validates : terms_of_ticket?, <span class=\"pl-c1\">acceptance:</span> <span class=\"pl-c1\">true</span>\nvalidates : terms_of_travel?, <span class=\"pl-c1\">acceptance:</span> <span class=\"pl-c1\">true</span></pre></div>\n<p>Plus: remove the <code>terms_accepted?</code> method, Rails does all this alone, including putting together the respective error message. The practical part about this: the validation only works if the attribute is give - so you'll still be able to create and update <code>ConferencePreferences</code> outside the context of user-interaction.</p>\n<p>I put together a small <a href=\"https://gist.github.com/klappradla/80eeda7538fd5a924ef83817156b8ffe\">Rails app for you as an example</a>:</p>\n<div class=\"highlight highlight-source-ruby\"><pre><span class=\"pl-k\">begin</span>\n  <span class=\"pl-k\">require</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>bundler/inline<span class=\"pl-pds\">\"</span></span>\n<span class=\"pl-k\">rescue</span> <span class=\"pl-c1\">LoadError</span> =&gt; e\n  <span class=\"pl-smi\">$stderr</span>.<span class=\"pl-c1\">puts</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Bundler version 1.10 or later is required. Please update your Bundler<span class=\"pl-pds\">\"</span></span>\n  <span class=\"pl-k\">raise</span> e\n<span class=\"pl-k\">end</span>\n\ngemfile(<span class=\"pl-c1\">true</span>) <span class=\"pl-k\">do</span>\n  source <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>https://rubygems.org<span class=\"pl-pds\">\"</span></span>\n\n  gem <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>rails<span class=\"pl-pds\">\"</span></span>\n  gem <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>pg<span class=\"pl-pds\">\"</span></span>\n  gem <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>pry<span class=\"pl-pds\">\"</span></span>\n<span class=\"pl-k\">end</span>\n\n<span class=\"pl-k\">require</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>active_record<span class=\"pl-pds\">\"</span></span>\n\n<span class=\"pl-c1\">ActiveRecord</span>::<span class=\"pl-c1\">Base</span>.establish_connection(<span class=\"pl-c1\">adapter:</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>postgresql<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">database:</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>validation_example<span class=\"pl-pds\">\"</span></span>)\n\n<span class=\"pl-c1\">ActiveRecord</span>::<span class=\"pl-c1\">Schema</span>.define <span class=\"pl-k\">do</span>\n  create_table <span class=\"pl-c1\">:users</span>, <span class=\"pl-c1\">force:</span> <span class=\"pl-c1\">true</span> <span class=\"pl-k\">do</span> |<span class=\"pl-smi\">t</span>|\n    t.string <span class=\"pl-c1\">:name</span>\n    t.timestamps\n  <span class=\"pl-k\">end</span>\n<span class=\"pl-k\">end</span>\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">User<span class=\"pl-e\"> &lt; ActiveRecord::Base</span></span>\n  validates_acceptance_of <span class=\"pl-c1\">:terms_of_service</span>\n<span class=\"pl-k\">end</span>\n\n<span class=\"pl-c1\">binding</span>.pry</pre></div>\n<p>It's a Rails app in one file. In order to run it, you have to do:</p>\n<div class=\"highlight highlight-source-shell\"><pre>createdb validation_example</pre></div>\n<p>once, and then</p>\n<div class=\"highlight highlight-source-shell\"><pre>ruby validation_example.rb <span class=\"pl-c\"><span class=\"pl-c\">#</span> or however the file is called</span></pre></div>\n<p>To run the app and get into an interactive pry session</p>\n<p><strong>But you don't have to do any of this</strong>, I ran the app for you and illustrated some examples of how this type of validation works:</p>\n<div class=\"highlight highlight-source-ruby\"><pre>[<span class=\"pl-c1\">1</span>] pry(main)<span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">User</span>.<span class=\"pl-k\">new</span>.valid?\n=&gt; <span class=\"pl-c1\">true</span>\n[<span class=\"pl-c1\">2</span>] pry(main)<span class=\"pl-k\">&gt;</span> user <span class=\"pl-k\">=</span> <span class=\"pl-c1\">User</span>.<span class=\"pl-k\">new</span>(<span class=\"pl-c1\">terms_of_service:</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>1<span class=\"pl-pds\">\"</span></span>)\n=&gt; <span class=\"pl-c\"><span class=\"pl-c\">#</span>&lt;User:0x007f951902e9e0 id: nil, name: nil, created_at: nil, updated_at: nil&gt;</span>\n[<span class=\"pl-c1\">3</span>] pry(main)<span class=\"pl-k\">&gt;</span> user.valid?\n=&gt; <span class=\"pl-c1\">true</span>\n[<span class=\"pl-c1\">4</span>] pry(main)<span class=\"pl-k\">&gt;</span> user <span class=\"pl-k\">=</span> <span class=\"pl-c1\">User</span>.<span class=\"pl-k\">new</span>(<span class=\"pl-c1\">terms_of_service:</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>0<span class=\"pl-pds\">\"</span></span>)\n=&gt; <span class=\"pl-c\"><span class=\"pl-c\">#</span>&lt;User:0x007f951813ed90 id: nil, name: nil, created_at: nil, updated_at: nil&gt;</span>\n[<span class=\"pl-c1\">5</span>] pry(main)<span class=\"pl-k\">&gt;</span> user.valid?\n=&gt; <span class=\"pl-c1\">false</span>\n[<span class=\"pl-c1\">6</span>] pry(main)<span class=\"pl-k\">&gt;</span> user.errors\n=&gt; <span class=\"pl-c\"><span class=\"pl-c\">#</span>&lt;ActiveModel::Errors:0x007f9518d0d298</span>\n <span class=\"pl-smi\">@base</span><span class=\"pl-k\">=</span><span class=\"pl-c\"><span class=\"pl-c\">#</span>&lt;User:0x007f951813ed90 id: nil, name: nil, created_at: nil, updated_at: nil&gt;,</span>\n <span class=\"pl-smi\">@details</span><span class=\"pl-k\">=</span>{<span class=\"pl-c1\">:terms_of_service</span>=&gt;[{<span class=\"pl-c1\">:error</span>=&gt;<span class=\"pl-c1\">:accepted</span>}]},\n <span class=\"pl-smi\">@messages</span><span class=\"pl-k\">=</span>{<span class=\"pl-c1\">:terms_of_service</span>=&gt;[<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>must be accepted<span class=\"pl-pds\">\"</span></span>]}<span class=\"pl-k\">&gt;</span>\n[<span class=\"pl-c1\">7</span>] pry(main)<span class=\"pl-k\">&gt;</span> user <span class=\"pl-k\">=</span> <span class=\"pl-c1\">User</span>.<span class=\"pl-k\">new</span>(<span class=\"pl-c1\">terms_of_service:</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>2<span class=\"pl-pds\">\"</span></span>)\n=&gt; <span class=\"pl-c\"><span class=\"pl-c\">#</span>&lt;User:0x007f9518458df0 id: nil, name: nil, created_at: nil, updated_at: nil&gt;</span>\n[<span class=\"pl-c1\">8</span>] pry(main)<span class=\"pl-k\">&gt;</span> user.valid?\n=&gt; <span class=\"pl-c1\">false</span>\n[<span class=\"pl-c1\">9</span>] pry(main)<span class=\"pl-k\">&gt;</span> user.errors\n=&gt; <span class=\"pl-c\"><span class=\"pl-c\">#</span>&lt;ActiveModel::Errors:0x007f951826e8c8</span>\n <span class=\"pl-smi\">@base</span><span class=\"pl-k\">=</span><span class=\"pl-c\"><span class=\"pl-c\">#</span>&lt;User:0x007f9518458df0 id: nil, name: nil, created_at: nil, updated_at: nil&gt;,</span>\n <span class=\"pl-smi\">@details</span><span class=\"pl-k\">=</span>{<span class=\"pl-c1\">:terms_of_service</span>=&gt;[{<span class=\"pl-c1\">:error</span>=&gt;<span class=\"pl-c1\">:accepted</span>}]},\n <span class=\"pl-smi\">@messages</span><span class=\"pl-k\">=</span>{<span class=\"pl-c1\">:terms_of_service</span>=&gt;[<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>must be accepted<span class=\"pl-pds\">\"</span></span>]}<span class=\"pl-k\">&gt;</span>\n[<span class=\"pl-c1\">10</span>] pry(main)<span class=\"pl-k\">&gt;</span></pre></div>\n<p>So as you see, Rails does all the work already for you! I would prefer to have Rails do the work in this case, instead of having to implement it ourself and testing it (we don't have to test Rails' internals, we'll just assume they work <g-emoji class=\"g-emoji\" alias=\"wink\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f609.png\">\ud83d\ude09</g-emoji> )</p>\n<p>So the boolean fields just have to be present in the form and allowed in the controller. For the rest, Rails will take care of things.</p>\n<p>Everything clear? Just ask me if this is still confusing</p>", "body_text": "Almost \ud83d\udcaa\nYou can spare the two attr_accessors - it's just about the input that's coming in via the controller (essentially the form in the end). So you need two validations:\nvalidates : terms_of_ticket?, acceptance: true\nvalidates : terms_of_travel?, acceptance: true\nPlus: remove the terms_accepted? method, Rails does all this alone, including putting together the respective error message. The practical part about this: the validation only works if the attribute is give - so you'll still be able to create and update ConferencePreferences outside the context of user-interaction.\nI put together a small Rails app for you as an example:\nbegin\n  require \"bundler/inline\"\nrescue LoadError => e\n  $stderr.puts \"Bundler version 1.10 or later is required. Please update your Bundler\"\n  raise e\nend\n\ngemfile(true) do\n  source \"https://rubygems.org\"\n\n  gem \"rails\"\n  gem \"pg\"\n  gem \"pry\"\nend\n\nrequire \"active_record\"\n\nActiveRecord::Base.establish_connection(adapter: \"postgresql\", database: \"validation_example\")\n\nActiveRecord::Schema.define do\n  create_table :users, force: true do |t|\n    t.string :name\n    t.timestamps\n  end\nend\n\nclass User < ActiveRecord::Base\n  validates_acceptance_of :terms_of_service\nend\n\nbinding.pry\nIt's a Rails app in one file. In order to run it, you have to do:\ncreatedb validation_example\nonce, and then\nruby validation_example.rb # or however the file is called\nTo run the app and get into an interactive pry session\nBut you don't have to do any of this, I ran the app for you and illustrated some examples of how this type of validation works:\n[1] pry(main)> User.new.valid?\n=> true\n[2] pry(main)> user = User.new(terms_of_service: \"1\")\n=> #<User:0x007f951902e9e0 id: nil, name: nil, created_at: nil, updated_at: nil>\n[3] pry(main)> user.valid?\n=> true\n[4] pry(main)> user = User.new(terms_of_service: \"0\")\n=> #<User:0x007f951813ed90 id: nil, name: nil, created_at: nil, updated_at: nil>\n[5] pry(main)> user.valid?\n=> false\n[6] pry(main)> user.errors\n=> #<ActiveModel::Errors:0x007f9518d0d298\n @base=#<User:0x007f951813ed90 id: nil, name: nil, created_at: nil, updated_at: nil>,\n @details={:terms_of_service=>[{:error=>:accepted}]},\n @messages={:terms_of_service=>[\"must be accepted\"]}>\n[7] pry(main)> user = User.new(terms_of_service: \"2\")\n=> #<User:0x007f9518458df0 id: nil, name: nil, created_at: nil, updated_at: nil>\n[8] pry(main)> user.valid?\n=> false\n[9] pry(main)> user.errors\n=> #<ActiveModel::Errors:0x007f951826e8c8\n @base=#<User:0x007f9518458df0 id: nil, name: nil, created_at: nil, updated_at: nil>,\n @details={:terms_of_service=>[{:error=>:accepted}]},\n @messages={:terms_of_service=>[\"must be accepted\"]}>\n[10] pry(main)>\nSo as you see, Rails does all the work already for you! I would prefer to have Rails do the work in this case, instead of having to implement it ourself and testing it (we don't have to test Rails' internals, we'll just assume they work \ud83d\ude09 )\nSo the boolean fields just have to be present in the form and allowed in the controller. For the rest, Rails will take care of things.\nEverything clear? Just ask me if this is still confusing"}