{"url": "https://api.github.com/repos/rails-girls-summer-of-code/rgsoc-teams/issues/comments/86202025", "html_url": "https://github.com/rails-girls-summer-of-code/rgsoc-teams/pull/171#issuecomment-86202025", "issue_url": "https://api.github.com/repos/rails-girls-summer-of-code/rgsoc-teams/issues/171", "id": 86202025, "user": {"login": "cypher", "id": 978, "avatar_url": "https://avatars2.githubusercontent.com/u/978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cypher", "html_url": "https://github.com/cypher", "followers_url": "https://api.github.com/users/cypher/followers", "following_url": "https://api.github.com/users/cypher/following{/other_user}", "gists_url": "https://api.github.com/users/cypher/gists{/gist_id}", "starred_url": "https://api.github.com/users/cypher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cypher/subscriptions", "organizations_url": "https://api.github.com/users/cypher/orgs", "repos_url": "https://api.github.com/users/cypher/repos", "events_url": "https://api.github.com/users/cypher/events{/privacy}", "received_events_url": "https://api.github.com/users/cypher/received_events", "type": "User", "site_admin": false}, "created_at": "2015-03-25T20:22:28Z", "updated_at": "2015-03-25T20:22:28Z", "author_association": "MEMBER", "body_html": "<p>TL;DR: A state machine adds little overhead, and provides stability and future extensibility.</p>\n<p>I've started working on <a href=\"https://github.com/rails-girls-summer-of-code/rgsoc-teams/issues/144\" class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"59447926\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/rails-girls-summer-of-code/rgsoc-teams/issues/144\">#144</a>, and the way I'm currently implementing it is actually an additional state in ApplicationDraft. That is, I've added a <code>mentor_signoff</code> event, that transitions an ApplicationDraft from <code>applied</code> to <code>signed_off</code>, which in turn could then trigger the conversion of an ApplicationDraft into an Application. This also ensures that a signed off ApplicationDraft cannot return to a previous state due to a bug.</p>\n<p>Additionally, something like a feedback loop might also be desirable at some point, that is, mentors could \"reject\" a draft, and return it to the applicants for additional editing. This could easily be implemented via the state machine, especially when it comes to notifying all the people involved.</p>\n<p>In theory, you could even stop using an extra model for the draft, and keep everything in the <code>Application</code> model, and then simply use a state machine to manage the different validations at each stage (but that would most likely be quite an undertaking, and probably not worth it).</p>", "body_text": "TL;DR: A state machine adds little overhead, and provides stability and future extensibility.\nI've started working on #144, and the way I'm currently implementing it is actually an additional state in ApplicationDraft. That is, I've added a mentor_signoff event, that transitions an ApplicationDraft from applied to signed_off, which in turn could then trigger the conversion of an ApplicationDraft into an Application. This also ensures that a signed off ApplicationDraft cannot return to a previous state due to a bug.\nAdditionally, something like a feedback loop might also be desirable at some point, that is, mentors could \"reject\" a draft, and return it to the applicants for additional editing. This could easily be implemented via the state machine, especially when it comes to notifying all the people involved.\nIn theory, you could even stop using an extra model for the draft, and keep everything in the Application model, and then simply use a state machine to manage the different validations at each stage (but that would most likely be quite an undertaking, and probably not worth it).", "body": "TL;DR: A state machine adds little overhead, and provides stability and future extensibility.\n\nI've started working on #144, and the way I'm currently implementing it is actually an additional state in ApplicationDraft. That is, I've added a `mentor_signoff` event, that transitions an ApplicationDraft from `applied` to `signed_off`, which in turn could then trigger the conversion of an ApplicationDraft into an Application. This also ensures that a signed off ApplicationDraft cannot return to a previous state due to a bug.\n\nAdditionally, something like a feedback loop might also be desirable at some point, that is, mentors could \"reject\" a draft, and return it to the applicants for additional editing. This could easily be implemented via the state machine, especially when it comes to notifying all the people involved.\n\nIn theory, you could even stop using an extra model for the draft, and keep everything in the `Application` model, and then simply use a state machine to manage the different validations at each stage (but that would most likely be quite an undertaking, and probably not worth it).\n"}